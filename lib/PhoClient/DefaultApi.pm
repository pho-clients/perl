=begin comment

Social Graph API

Pho Networks REST API

OpenAPI spec version: 1.1.1
Contact: emre@phonetworks.org
Generated by: https://github.com/swagger-api/swagger-codegen.git

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

=end comment

=cut

#
# NOTE: This class is auto generated by the swagger code generator program. 
# Do not edit the class manually.
# Ref: https://github.com/swagger-api/swagger-codegen
#
package PhoClient::DefaultApi;

require 5.6.0;
use strict;
use warnings;
use utf8; 
use Exporter;
use Carp qw( croak );
use Log::Any qw($log);

use PhoClient::ApiClient;
use PhoClient::Configuration;

use base "Class::Data::Inheritable";

__PACKAGE__->mk_classdata('method_documentation' => {});

sub new {
    my $class   = shift;
    my (%self) = (
        'api_client' => PhoClient::ApiClient->instance,
        @_
    );

    #my $self = {
    #    #api_client => $options->{api_client}
    #    api_client => $default_api_client
    #}; 

    bless \%self, $class;

}


#
# add_attribute
#
# updates (or creates) an attribute
# 
# @param string $value The value to update the key with. (optional)
{
    my $params = {
    'value' => {
        data_type => 'string',
        description => 'The value to update the key with.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'add_attribute' } = { 
    	summary => 'updates (or creates) an attribute',
        params => $params,
        returns => 'InlineResponse2004',
        };
}
# @return InlineResponse2004
#
sub add_attribute {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/{uuid}/attribute/{key}';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'value'}) {
        $_body_data = $args{'value'};
    }

    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('InlineResponse2004', $response);
    return $_response_object;
}

#
# del_attribute
#
# deletes an attribute
# 
{
    my $params = {
    };
    __PACKAGE__->method_documentation->{ 'del_attribute' } = { 
    	summary => 'deletes an attribute',
        params => $params,
        returns => 'InlineResponse2004',
        };
}
# @return InlineResponse2004
#
sub del_attribute {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/{uuid}/attribute/{key}';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('InlineResponse2004', $response);
    return $_response_object;
}

#
# del_entity
#
# deletes an entity
# 
{
    my $params = {
    };
    __PACKAGE__->method_documentation->{ 'del_entity' } = { 
    	summary => 'deletes an entity',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub del_entity {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/{uuid}';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# get_all_edges
#
# retrieves the edges of a node
# 
# @param string $uuid The node ID (required)
{
    my $params = {
    'uuid' => {
        data_type => 'string',
        description => 'The node ID',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_all_edges' } = { 
    	summary => 'retrieves the edges of a node',
        params => $params,
        returns => 'InlineResponse2003',
        };
}
# @return InlineResponse2003
#
sub get_all_edges {
    my ($self, %args) = @_;

    # verify the required parameter 'uuid' is set
    unless (exists $args{'uuid'}) {
      croak("Missing the required parameter 'uuid' when calling get_all_edges");
    }

    # parse inputs
    my $_resource_path = '/{uuid}/edges/all';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'uuid'}) {
        my $_base_variable = "{" . "uuid" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'uuid'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('InlineResponse2003', $response);
    return $_response_object;
}

#
# get_attribute
#
# retrieves the value of an entity attribute
# 
# @param string $uuid The node ID (required)
# @param string $key The attribute key (required)
{
    my $params = {
    'uuid' => {
        data_type => 'string',
        description => 'The node ID',
        required => '1',
    },
    'key' => {
        data_type => 'string',
        description => 'The attribute key',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_attribute' } = { 
    	summary => 'retrieves the value of an entity attribute',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub get_attribute {
    my ($self, %args) = @_;

    # verify the required parameter 'uuid' is set
    unless (exists $args{'uuid'}) {
      croak("Missing the required parameter 'uuid' when calling get_attribute");
    }

    # verify the required parameter 'key' is set
    unless (exists $args{'key'}) {
      croak("Missing the required parameter 'key' when calling get_attribute");
    }

    # parse inputs
    my $_resource_path = '/{uuid}/attribute/{key}';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'uuid'}) {
        my $_base_variable = "{" . "uuid" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'uuid'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'key'}) {
        my $_base_variable = "{" . "key" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'key'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# get_attributes
#
# retrieves the existing attribute keys of an entity (edge or node)
# 
# @param string $uuid The node ID (required)
{
    my $params = {
    'uuid' => {
        data_type => 'string',
        description => 'The node ID',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_attributes' } = { 
    	summary => 'retrieves the existing attribute keys of an entity (edge or node)',
        params => $params,
        returns => 'ARRAY[string]',
        };
}
# @return ARRAY[string]
#
sub get_attributes {
    my ($self, %args) = @_;

    # verify the required parameter 'uuid' is set
    unless (exists $args{'uuid'}) {
      croak("Missing the required parameter 'uuid' when calling get_attributes");
    }

    # parse inputs
    my $_resource_path = '/{uuid}/attributes';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'uuid'}) {
        my $_base_variable = "{" . "uuid" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'uuid'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[string]', $response);
    return $_response_object;
}

#
# get_edge
#
# retrieves an edge
# 
# @param string $uuid The edge ID (required)
{
    my $params = {
    'uuid' => {
        data_type => 'string',
        description => 'The edge ID',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_edge' } = { 
    	summary => 'retrieves an edge',
        params => $params,
        returns => 'Edge',
        };
}
# @return Edge
#
sub get_edge {
    my ($self, %args) = @_;

    # verify the required parameter 'uuid' is set
    unless (exists $args{'uuid'}) {
      croak("Missing the required parameter 'uuid' when calling get_edge");
    }

    # parse inputs
    my $_resource_path = '/edge/{uuid}';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'uuid'}) {
        my $_base_variable = "{" . "uuid" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'uuid'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('Edge', $response);
    return $_response_object;
}

#
# get_edge_getters
#
# retrieves the edge getter methods of a node
# 
# @param string $uuid The node ID (required)
{
    my $params = {
    'uuid' => {
        data_type => 'string',
        description => 'The node ID',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_edge_getters' } = { 
    	summary => 'retrieves the edge getter methods of a node',
        params => $params,
        returns => 'ARRAY[string]',
        };
}
# @return ARRAY[string]
#
sub get_edge_getters {
    my ($self, %args) = @_;

    # verify the required parameter 'uuid' is set
    unless (exists $args{'uuid'}) {
      croak("Missing the required parameter 'uuid' when calling get_edge_getters");
    }

    # parse inputs
    my $_resource_path = '/{uuid}/edges/getters';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'uuid'}) {
        my $_base_variable = "{" . "uuid" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'uuid'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[string]', $response);
    return $_response_object;
}

#
# get_edge_setters
#
# retrieves the edge setter methods of a node
# 
# @param string $uuid The node ID (required)
{
    my $params = {
    'uuid' => {
        data_type => 'string',
        description => 'The node ID',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_edge_setters' } = { 
    	summary => 'retrieves the edge setter methods of a node',
        params => $params,
        returns => 'ARRAY[string]',
        };
}
# @return ARRAY[string]
#
sub get_edge_setters {
    my ($self, %args) = @_;

    # verify the required parameter 'uuid' is set
    unless (exists $args{'uuid'}) {
      croak("Missing the required parameter 'uuid' when calling get_edge_setters");
    }

    # parse inputs
    my $_resource_path = '/{uuid}/edges/setters';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'uuid'}) {
        my $_base_variable = "{" . "uuid" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'uuid'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[string]', $response);
    return $_response_object;
}

#
# get_founder
#
# retrieves the Graph Founder
# 
{
    my $params = {
    };
    __PACKAGE__->method_documentation->{ 'get_founder' } = { 
    	summary => 'retrieves the Graph Founder',
        params => $params,
        returns => 'InlineResponse200',
        };
}
# @return InlineResponse200
#
sub get_founder {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/founder';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('InlineResponse200', $response);
    return $_response_object;
}

#
# get_graph
#
# retrieves the main Graph
# 
{
    my $params = {
    };
    __PACKAGE__->method_documentation->{ 'get_graph' } = { 
    	summary => 'retrieves the main Graph',
        params => $params,
        returns => 'InlineResponse2001',
        };
}
# @return InlineResponse2001
#
sub get_graph {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/graph';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('InlineResponse2001', $response);
    return $_response_object;
}

#
# get_incoming_edges
#
# retrieves the incoming edges of a node
# 
# @param string $uuid the node ID (required)
{
    my $params = {
    'uuid' => {
        data_type => 'string',
        description => 'the node ID',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_incoming_edges' } = { 
    	summary => 'retrieves the incoming edges of a node',
        params => $params,
        returns => 'ARRAY[NodeEdge]',
        };
}
# @return ARRAY[NodeEdge]
#
sub get_incoming_edges {
    my ($self, %args) = @_;

    # verify the required parameter 'uuid' is set
    unless (exists $args{'uuid'}) {
      croak("Missing the required parameter 'uuid' when calling get_incoming_edges");
    }

    # parse inputs
    my $_resource_path = '/{uuid}/edges/in';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'uuid'}) {
        my $_base_variable = "{" . "uuid" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'uuid'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[NodeEdge]', $response);
    return $_response_object;
}

#
# get_node
#
# retrieves a node
# 
# @param string $uuid The node ID (required)
{
    my $params = {
    'uuid' => {
        data_type => 'string',
        description => 'The node ID',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_node' } = { 
    	summary => 'retrieves a node',
        params => $params,
        returns => 'Node',
        };
}
# @return Node
#
sub get_node {
    my ($self, %args) = @_;

    # verify the required parameter 'uuid' is set
    unless (exists $args{'uuid'}) {
      croak("Missing the required parameter 'uuid' when calling get_node");
    }

    # parse inputs
    my $_resource_path = '/{uuid}';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'uuid'}) {
        my $_base_variable = "{" . "uuid" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'uuid'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('Node', $response);
    return $_response_object;
}

#
# get_node_edge
#
# edge getter
# 
# @param string $uuid The node ID (required)
# @param string $edge The edge getter label (required)
{
    my $params = {
    'uuid' => {
        data_type => 'string',
        description => 'The node ID',
        required => '1',
    },
    'edge' => {
        data_type => 'string',
        description => 'The edge getter label',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_node_edge' } = { 
    	summary => 'edge getter',
        params => $params,
        returns => 'ARRAY[string]',
        };
}
# @return ARRAY[string]
#
sub get_node_edge {
    my ($self, %args) = @_;

    # verify the required parameter 'uuid' is set
    unless (exists $args{'uuid'}) {
      croak("Missing the required parameter 'uuid' when calling get_node_edge");
    }

    # verify the required parameter 'edge' is set
    unless (exists $args{'edge'}) {
      croak("Missing the required parameter 'edge' when calling get_node_edge");
    }

    # parse inputs
    my $_resource_path = '/{uuid}/{edge}';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'uuid'}) {
        my $_base_variable = "{" . "uuid" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'uuid'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'edge'}) {
        my $_base_variable = "{" . "edge" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'edge'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[string]', $response);
    return $_response_object;
}

#
# get_outgoing_edges
#
# retrieves the outgoing edges of a node
# 
# @param string $uuid the node ID (required)
{
    my $params = {
    'uuid' => {
        data_type => 'string',
        description => 'the node ID',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_outgoing_edges' } = { 
    	summary => 'retrieves the outgoing edges of a node',
        params => $params,
        returns => 'ARRAY[NodeEdge]',
        };
}
# @return ARRAY[NodeEdge]
#
sub get_outgoing_edges {
    my ($self, %args) = @_;

    # verify the required parameter 'uuid' is set
    unless (exists $args{'uuid'}) {
      croak("Missing the required parameter 'uuid' when calling get_outgoing_edges");
    }

    # parse inputs
    my $_resource_path = '/{uuid}/edges/out';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'uuid'}) {
        my $_base_variable = "{" . "uuid" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'uuid'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[NodeEdge]', $response);
    return $_response_object;
}

#
# get_space
#
# retrieves the Space
# 
{
    my $params = {
    };
    __PACKAGE__->method_documentation->{ 'get_space' } = { 
    	summary => 'retrieves the Space',
        params => $params,
        returns => 'InlineResponse2002',
        };
}
# @return InlineResponse2002
#
sub get_space {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/space';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('InlineResponse2002', $response);
    return $_response_object;
}

#
# get_type
#
# fetches entity type
# 
# @param string $uuid the node (required)
{
    my $params = {
    'uuid' => {
        data_type => 'string',
        description => 'the node',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_type' } = { 
    	summary => 'fetches entity type',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub get_type {
    my ($self, %args) = @_;

    # verify the required parameter 'uuid' is set
    unless (exists $args{'uuid'}) {
      croak("Missing the required parameter 'uuid' when calling get_type");
    }

    # parse inputs
    my $_resource_path = '/{uuid}/type';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'uuid'}) {
        my $_base_variable = "{" . "uuid" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'uuid'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# make_actor
#
# creates an Actor object
# 
# @param string $param1 Actor constructor argument. More parameters may be passed via param2, param3 ... param50.  (optional)
{
    my $params = {
    'param1' => {
        data_type => 'string',
        description => 'Actor constructor argument. More parameters may be passed via param2, param3 ... param50. ',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'make_actor' } = { 
    	summary => 'creates an Actor object',
        params => $params,
        returns => 'UUID',
        };
}
# @return UUID
#
sub make_actor {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/actor';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    my $_body_data;
    # body params
    if ( exists $args{'param1'}) {
        $_body_data = $args{'param1'};
    }

    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('UUID', $response);
    return $_response_object;
}

#
# make_edge
#
# creates an edge
# 
# @param string $param1 The value to update the key with. There can be 50 of those. For example;  param1&#x3D;\&quot;value1\&quot;, param2 &#x3D;\&quot;another value\&quot; depending on the edge&#39;s default constructor variable count.  (optional)
{
    my $params = {
    'param1' => {
        data_type => 'string',
        description => 'The value to update the key with. There can be 50 of those. For example;  param1&#x3D;\&quot;value1\&quot;, param2 &#x3D;\&quot;another value\&quot; depending on the edge&#39;s default constructor variable count. ',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'make_edge' } = { 
    	summary => 'creates an edge',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub make_edge {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/{uuid}/{edge}';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'param1'}) {
        $_body_data = $args{'param1'};
    }

    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# set_attribute
#
# updates (or creates) an attribute
# 
# @param string $value The value to update the key with. (optional)
{
    my $params = {
    'value' => {
        data_type => 'string',
        description => 'The value to update the key with.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'set_attribute' } = { 
    	summary => 'updates (or creates) an attribute',
        params => $params,
        returns => 'InlineResponse2004',
        };
}
# @return InlineResponse2004
#
sub set_attribute {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/{uuid}/attribute/{key}';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'value'}) {
        $_body_data = $args{'value'};
    }

    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('InlineResponse2004', $response);
    return $_response_object;
}

1;
